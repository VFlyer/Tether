using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using KModkit;

public class TormentScript : MonoBehaviour
{
    public KMAudio Audio;
    public KMBombInfo Bomb;
    public KMBombModule Module;

    public KMSelectable[] Tiles;
    public KMSelectable UNDO;
    public AudioSource MusicPlayer;
    public AudioClip[] SFX;
    public TextMesh[] UNDOING;

    List<int[]> TormentRange = new List<int[]>();
    List<int[]> NumberAddition = new List<int[]>();
    List<string> CoordinatesToPress = new List<string>();
    int[] NumberBasis = new int[16], NumberComparer = new int[16], PressAmount = new int[16], PressedNumbers = { -1, -1, -1, -1 };
    string[] CoordinatesCodename = { "A1", "B1", "C1", "D1", "A2", "B2", "C2", "D2", "A3", "B3", "C3", "D3", "A4", "B4", "C4", "D4" };
    bool Interactable = false, Touchable = true;
    int BaseNumber = 0, PhaseNumber = 0, PressNumber = 0, NumberOfSeconds = 10;
    string CodeWord = "LOOK";

    //Logging
    static int moduleIdCounter = 1;
    int moduleId;
    private bool ModuleSolved;

    void Awake()
    {
        moduleId = moduleIdCounter++;
        for (int i = 0; i < 16; i++)
        {
            int Tile = i;
            Tiles[i].OnInteract += delegate
            {
                PressTile(Tile);
                return false;
            };
        }
        UNDO.OnInteract += delegate () { DifferentFunctions(); return false; };
    }

    void Start()
    {
        BaseNumber = UnityEngine.Random.Range(0, 3);
        for (int x = 0; x < NumberBasis.Length; x++)
        {
            NumberComparer[x] = NumberBasis[x] = BaseNumber;
            PressAmount[x] = 0;
            int TormentAmount = UnityEngine.Random.Range(7, 10);
            int[] NumberShuffle = Enumerable.Range(0, 16).ToArray().Shuffle();
            List<int> TempNumberList = new List<int>();
            List<int> TempNumberAdditionList = new List<int>();
            for (int y = 0; y < TormentAmount; y++)
            {
                TempNumberList.Add(NumberShuffle[y]);
                TempNumberAdditionList.Add(UnityEngine.Random.Range(1, 3));
            }
            TormentRange.Add(TempNumberList.ToArray());
            NumberAddition.Add(TempNumberAdditionList.ToArray());
        }


        for (int a = 0; a < 3; a++)
        {
            int NumberPick = -1;
            do
            {
                NumberPick = UnityEngine.Random.Range(0, 16);
            }
            while (PressAmount[NumberPick] == 1);
            CoordinatesToPress.Add(CoordinatesCodename[NumberPick]);
            PressAmount[NumberPick]++;
            for (int x = 0; x < TormentRange[NumberPick].Length; x++)
            {
                NumberComparer[TormentRange[NumberPick][x]] = (NumberComparer[TormentRange[NumberPick][x]] + NumberAddition[NumberPick][x]) % 3;
            }
        }

        for (int x = 0; x < NumberComparer.Length; x++)
        {
            Tiles[x].GetComponentInChildren<TextMesh>().text = NumberComparer[x].ToString();
        }
        Debug.LogFormat("[Torment #{0}] ------------------------------------------------------------------", moduleId);
        Debug.LogFormat("[Torment #{0}] The grid generated by the module: ", moduleId);
        string Grid = "";
        for (int x = 0; x < Tiles.Length; x++)
        {
            Grid += Tiles[x].GetComponentInChildren<TextMesh>().text;
            if (x % 4 == 3)
            {
                Debug.LogFormat("[Torment #{0}] {1}", moduleId, Grid);
                Grid = "";
            }
        }
        Debug.LogFormat("[Torment #{0}] The base number used on the grid is: {1}", moduleId, BaseNumber.ToString());
        for (int x = 0; x < NumberComparer.Length; x++)
        {
            int[] loggingInts = new int[16];
            string DebugString = "";

            for (int y = 0; y < TormentRange[x].Length; y++)
                loggingInts[TormentRange[x][y]] = NumberAddition[x][y];

            for (int y = 0; y < 4; y++)
                DebugString += Enumerable.Range(y * 4, 4).Select(z => loggingInts[z]).Join("") + (y != 3 ? "|" : "");

            Debug.LogFormat("[Torment #{0}] The matrix for tile {1} is: {2}", moduleId, CoordinatesCodename[x], DebugString);
        }
        string DebugString2 = "";
        for (int x = 0; x < CoordinatesToPress.Count(); x++)
        {
            DebugString2 = DebugString2 + CoordinatesToPress[x] + (x < CoordinatesToPress.Count() - 1 ? ", " : "");
        }
        Debug.LogFormat("[Torment #{0}] The tiles should be pressed (based on my algorithm) are: {1}", moduleId, DebugString2);
        NumberOfSeconds = 10;
        StartCoroutine(Ten());
    }

    void DifferentFunctions()
    {
        UNDO.AddInteractionPunch(0.2f);
        if (!ModuleSolved && Touchable)
        {
            Audio.PlaySoundAtTransform(SFX[0].name, transform);
            if (PhaseNumber == 0)
            {
                CodeWord = "FALL";
                for (int x = 0; x < 4; x++)
                {
                    UNDOING[x].text = CodeWord[x].ToString();
                }
                for (int x = 0; x < 16; x++)
                {
                    Tiles[x].GetComponentInChildren<TextMesh>().text = "-";
                }
                PhaseNumber = 1;
                Interactable = true;
            }

            else if (PhaseNumber == 1)
            {
                CodeWord = "STOP";
                for (int x = 0; x < 4; x++)
                {
                    UNDOING[x].text = CodeWord[x].ToString();
                }
                for (int x = 0; x < 16; x++)
                {
                    Tiles[x].GetComponentInChildren<TextMesh>().text = NumberBasis[x].ToString();
                    Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0, 2, 5, 7, 8, 10, 13, 15) ? new Color32(0, 0, 0, 255) : new Color32(255, 0, 0, 255);
                }
                PhaseNumber = 2;
            }

            else if (PhaseNumber == 2 && NumberOfSeconds == 0)
            {
                CodeWord = "LOOK";
                for (int x = 0; x < 4; x++)
                {
                    UNDOING[x].text = CodeWord[x].ToString();
                }
                for (int x = 0; x < 16; x++)
                {
                    Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0, 2, 5, 7, 8, 10, 13, 15) ? new Color32(0, 0, 0, 255) : new Color32(255, 0, 0, 255);
                }
                TormentRange = new List<int[]>(); NumberAddition = new List<int[]>();
                NumberBasis = new int[16]; NumberComparer = new int[16]; PressAmount = new int[16];
                PressedNumbers = new int[] { -1, -1, -1, -1 };
                CoordinatesToPress = new List<string>();
                PhaseNumber = 0; PressNumber = 0;
                Start();
            }
        }
    }

    void PressTile(int Tile)
    {
        Tiles[Tile].AddInteractionPunch(0.2f);
        if (!ModuleSolved && Interactable && Touchable)
        {
            if (PhaseNumber == 1)
            {
                Audio.PlaySoundAtTransform(SFX[0].name, transform);
                for (int x = 0; x < NumberBasis.Length; x++)
                {
                    Tiles[x].GetComponentInChildren<TextMesh>().text = "-";
                    Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0, 2, 5, 7, 8, 10, 13, 15) ? new Color32(0, 0, 0, 255) : new Color32(255, 0, 0, 255);
                }

                for (int x = 0; x < TormentRange[Tile].Length; x++)
                {
                    Tiles[TormentRange[Tile][x]].GetComponentInChildren<TextMesh>().color = new Color32(255, 255, 255, 255);
                    Tiles[TormentRange[Tile][x]].GetComponentInChildren<TextMesh>().text = NumberAddition[Tile][x].ToString();
                }
            }

            else if (PhaseNumber == 2 && PressNumber < 3 && !new[] { Tile }.Any(c => PressedNumbers.Contains(c)))
            {
                Audio.PlaySoundAtTransform(SFX[0].name, transform);
                for (int z = 0; z < TormentRange[Tile].Length; z++)
                {
                    NumberBasis[TormentRange[Tile][z]] = (NumberBasis[TormentRange[Tile][z]] + (NumberAddition[Tile][z])) % 3;
                }
                Tiles[Tile].GetComponentInChildren<TextMesh>().color = new Color32(255, 255, 255, 255);

                for (int x = 0; x < NumberBasis.Length; x++)
                {
                    Tiles[x].GetComponentInChildren<TextMesh>().text = NumberBasis[x].ToString();
                }

                PressedNumbers[PressNumber] = Tile;
                Debug.LogFormat("[Torment #{0}] You pressed {1}", moduleId, CoordinatesCodename[Tile], PressAmount[Tile].ToString());
                PressNumber++;

                if (PressNumber == 3)
                {
                    Interactable = false;
                    for (int x = 0; x < NumberBasis.Length; x++)
                    {
                        if (NumberBasis[x] != NumberComparer[x])
                        {
                            return;
                        }
                    }
                    for (int a = 0; a < 4; a++)
                    {
                        UNDOING[a].text = "";
                    }
                    Touchable = false;
                    Debug.LogFormat("[Torment #{0}] They have been fully binded. Module solved.", moduleId);
                    StartCoroutine(WillAllwaysHappen());
                }
            }
        }
    }

    IEnumerator WillAllwaysHappen()
    {
        for (int x = 0; x < NumberBasis.Length; x++)
        {
            Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0, 2, 5, 7, 8, 10, 13, 15) ? new Color32(0, 0, 0, 255) : new Color32(255, 0, 0, 255);
            Tiles[x].GetComponentInChildren<TextMesh>().text = "";
        }
        MusicPlayer.clip = SFX[2];
        MusicPlayer.Play();
        while (MusicPlayer.isPlaying)
        {
            yield return new WaitForSecondsRealtime(0.01f);
        }
        ModuleSolved = true;
        Module.HandlePass();
        MusicPlayer.clip = SFX[1];
        MusicPlayer.Play();
        string[] TheVoidSpeaks = { "WE  WILLCOMEBACK", "THE VOIDWILLLIVE", "YOU WILLSEE SOON", "YOU HAVENOT WON ", "THISWILLNOT END ", "COMEAND JOINUS  ", "NO  ONE TO  HELP", "NO  ONE WILLHELP", "WE  SEE YOUREND ", "YOU ARE NOT SAFE", "YOU WILLBE  BACK", "YOUREYESONLYLIE ", "YOU WILLFEARUS  ", "OUR TIMEWILLCOME", "YOURLIFEWILLEND ", "DO  NOT LOOKBACK", "NO  ONE IS  HERE", "THISIS  THE END " };
        int ChosenDestiny = UnityEngine.Random.Range(0, TheVoidSpeaks.Length);
        while (MusicPlayer.isPlaying)
        {
            for (int x = 0; x < 2; x++)
            {
                for (int y = 0; y < NumberBasis.Length; y++)
                {
                    Tiles[y].GetComponentInChildren<TextMesh>().text = x == 0 ? TheVoidSpeaks[ChosenDestiny][y].ToString() : "";
                }
                yield return new WaitForSecondsRealtime(0.1f);
            }
        }
    }

    IEnumerator Ten()
    {
        while (NumberOfSeconds != 0)
        {
            yield return new WaitForSecondsRealtime(1f);
            NumberOfSeconds--;
        }
    }

    //twitch plays
#pragma warning disable 414
    private readonly string TwitchHelpMessage = "To press the button on top, use the command \"!{0} look/fall/stop\" | To press a certain coordinate on the module (A - D top to bottom, 1 - 4 left to right), use the command \"!{0} press [A-D][1-4]\" Multiple coordinates can be specified.";
#pragma warning restore 414

    IEnumerator ProcessTwitchCommand(string command)
    {
        string[] parameters = command.Split(' ');
        if (command.ToUpper() == CodeWord)
        {
            if (!Touchable)
            {
                yield return "sendtochaterror You can not interact with the button currently. Command ignored.";
                yield break;
            }

            if (CodeWord == "STOP" && NumberOfSeconds != 0)
            {
                yield return "sendtochaterror You can not leave yet. Command ignored.";
                yield break;
            }
            yield return null;
            UNDO.OnInteract();
        }

        if (Regex.IsMatch(parameters[0], @"^\s*press\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
        {
            if (parameters.Length < 2)
            {
                yield return "sendtochaterror Invalid parameter length. Command ignored.";
                yield break;
            }

            if (!Interactable || !Touchable)
            {
                yield return "sendtochaterror You can not interact with the tiles currently. Command ignored.";
                yield break;
            }
            var possiblePresses = new List<KMSelectable>();
            foreach (var possibleCoord in parameters.Skip(1))
            {
                var possibleCoordUpper = possibleCoord.ToUpper();
                if (!possibleCoordUpper.EqualsAny(CoordinatesCodename))
                {
                    yield return string.Format("sendtochaterror Invalid coordinate \"{0}\" was detected. The command was not continued.", possibleCoordUpper);
                    yield break;
                }
                possiblePresses.Add(Tiles[CoordinatesCodename.ToList().IndexOf(possibleCoordUpper)]);
            }
            foreach (var aButton in possiblePresses)
            {
                yield return null;
                if (CodeWord == "STOP" && PressNumber == 2)
                    yield return "solve";
                aButton.OnInteract();
                yield return new WaitForSeconds(0.1f);
            }
        }
    }

    IEnumerator TwitchHandleForcedSolve()
    {
        waitForReset:
        while (NumberOfSeconds > 0)
            yield return true;
        while (CodeWord != "STOP")
        {
            UNDO.OnInteract();
            yield return new WaitForSeconds(0.1f);
        }
        if (PressNumber > 0 && !PressedNumbers.Take(PressNumber).All(a => CoordinatesToPress.Contains(CoordinatesCodename[a])))
        {
            UNDO.OnInteract();
            goto waitForReset;
        }
        while (PressNumber < 3)
        {
            var remainingCoords = CoordinatesToPress.Select(a => CoordinatesCodename.ToList().IndexOf(a)).Except(PressedNumbers.Take(PressNumber));
            Tiles[remainingCoords.FirstOrDefault()].OnInteract();
            yield return new WaitForSeconds(0.1f);
        }
        while (!ModuleSolved)
            yield return true;
    }
}
