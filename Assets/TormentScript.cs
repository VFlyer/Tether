using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using KModkit;

public class TormentScript : MonoBehaviour
{
	public KMAudio Audio;
    public KMBombInfo Bomb;
	public KMBombModule Module;
	
	public KMSelectable[] Tiles;
	public KMSelectable UNDO;
	public AudioSource MusicPlayer;
	public AudioClip[] SFX;
	public TextMesh[] UNDOING;
	
	List<int[]> TormentRange = new List<int[]>();
	List<int[]> NumberAddition = new List<int[]>();
	List<string> CoordinatesToPress = new List<string>();
	int[] NumberBasis = new int[16], NumberComparer = new int[16], PressAmount = new int[16], PressedNumbers = {-1, -1, -1, -1};
	string[] CoordinatesCodename = {"A1", "B1", "C1", "D1", "A2", "B2", "C2", "D2", "A3", "B3", "C3", "D3", "A4", "B4", "C4", "D4"};
	bool Interactable = false, Touchable = true;
	int BaseNumber = 0, PhaseNumber = 0, PressNumber = 0, NumberOfSeconds = 10;
	string CodeWord = "LOOK";

	//Logging
	static int moduleIdCounter = 1;
    int moduleId;
    private bool ModuleSolved;
	
	void Awake()
	{
		moduleId = moduleIdCounter++;
		for (int i = 0; i < 16; i++)
		{
			int Tile = i;
			Tiles[i].OnInteract += delegate
			{
				PressTile(Tile);
				return false; 
			};
		}
		UNDO.OnInteract += delegate () { DifferentFunctions(); return false; };
	}
	
	void Start()
	{
		BaseNumber = UnityEngine.Random.Range(0,3);
		for (int x = 0; x < NumberBasis.Length; x++)
		{
			NumberComparer[x] = NumberBasis[x] = BaseNumber;
			PressAmount[x] = 0;
			int TormentAmount = UnityEngine.Random.Range(7,10);
			int[] NumberShuffle = Enumerable.Range(0,16).ToArray().Shuffle();
			List<int> TempNumberList = new List<int>();
			List<int> TempNumberAdditionList = new List<int>();
			for (int y = 0; y < TormentAmount; y++)
			{
				TempNumberList.Add(NumberShuffle[y]);
				TempNumberAdditionList.Add(UnityEngine.Random.Range(1,3));
			}
			TormentRange.Add(TempNumberList.ToArray());
			NumberAddition.Add(TempNumberAdditionList.ToArray());
		}
		
		
		for (int a = 0; a < 3; a++)
		{
			int NumberPick = -1;
			do
			{
				NumberPick = UnityEngine.Random.Range(0,16);
			}
			while (PressAmount[NumberPick] == 1);
			CoordinatesToPress.Add(CoordinatesCodename[NumberPick]);
			PressAmount[NumberPick]++;
			for (int x = 0; x < TormentRange[NumberPick].Length; x++)
			{
				NumberComparer[TormentRange[NumberPick][x]] = (NumberComparer[TormentRange[NumberPick][x]] + NumberAddition[NumberPick][x]) % 3;
			}
		}
		
		for (int x = 0; x < NumberComparer.Length; x++)
		{
			Tiles[x].GetComponentInChildren<TextMesh>().text = NumberComparer[x].ToString();
		}
		Debug.LogFormat("[Torment #{0}] ------------------------------------------------------------------", moduleId);
		Debug.LogFormat("[Torment #{0}] The grid generated by the module: ", moduleId);
		string Grid = "";
		for (int x = 0; x < Tiles.Length; x++)
		{
			Grid += Tiles[x].GetComponentInChildren<TextMesh>().text;
			if (x % 4 == 3)
			{
				Debug.LogFormat("[Torment #{0}] {1}", moduleId, Grid);
				Grid = "";
			}
		}
		Debug.LogFormat("[Torment #{0}] The base number used on the grid is: {1}", moduleId, BaseNumber.ToString());
		for (int x = 0; x < NumberComparer.Length; x++)
		{
			string DebugString = "";
			for (int y = 0; y < TormentRange[x].Length; y++)
			{
				DebugString = DebugString + CoordinatesCodename[TormentRange[x][y]] + ":" + NumberAddition[x][y].ToString() + (y < TormentRange[x].Length - 1 ? ", " : "");
			}
			Debug.LogFormat("[Torment #{0}] The tiles that changes when you press {1} are: {2}", moduleId, CoordinatesCodename[x], DebugString);
		}
		string DebugString2 = "";
		for (int x = 0; x < CoordinatesToPress.Count(); x++)
		{
			DebugString2 = DebugString2 + CoordinatesToPress[x] + (x < CoordinatesToPress.Count() - 1 ? ", " : "");
		}
		Debug.LogFormat("[Torment #{0}] The tiles should be pressed (based on my algorithm) are: {1}", moduleId, DebugString2);
		NumberOfSeconds = 10;
		StartCoroutine(Ten());
    }
	
	void DifferentFunctions()
	{
		UNDO.AddInteractionPunch(0.2f);
		if (!ModuleSolved && Touchable)
		{
			Audio.PlaySoundAtTransform(SFX[0].name, transform);
			if (PhaseNumber == 0)
			{
				CodeWord = "FALL";
				for (int x = 0; x < 4; x++)
				{
					UNDOING[x].text = CodeWord[x].ToString();
				}
				for (int x = 0; x < 16; x++)
				{
					Tiles[x].GetComponentInChildren<TextMesh>().text = "-";
				}
				PhaseNumber = 1;
				Interactable = true;
			}
			
			else if (PhaseNumber == 1)
			{
				CodeWord = "STOP";
				for (int x = 0; x < 4; x++)
				{
					UNDOING[x].text = CodeWord[x].ToString();
				}
				for (int x = 0; x < 16; x++)
				{
					Tiles[x].GetComponentInChildren<TextMesh>().text = NumberBasis[x].ToString();
					Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0,2,5,7,8,10,13,15) ? new Color32(0,0,0,255) : new Color32(255,0,0,255);
				}
				PhaseNumber = 2;
			}
			
			else if (PhaseNumber == 2 && NumberOfSeconds == 0)
			{
				CodeWord = "LOOK";
				for (int x = 0; x < 4; x++)
				{
					UNDOING[x].text = CodeWord[x].ToString();
				}
				for (int x = 0; x < 16; x++)
				{
					Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0,2,5,7,8,10,13,15) ? new Color32(0,0,0,255) : new Color32(255,0,0,255);
				}
				TormentRange = new List<int[]>(); NumberAddition = new List<int[]>();
				NumberBasis = new int[16]; NumberComparer = new int[16]; PressAmount = new int[16];
				PressedNumbers = new int[] {-1, -1, -1, -1};
				CoordinatesToPress = new List<string>();
				PhaseNumber = 0; PressNumber = 0;
				Start();
			}
		}
	}
	
	void PressTile(int Tile)
	{
		Tiles[Tile].AddInteractionPunch(0.2f);
		if (!ModuleSolved && Interactable && Touchable)
		{
			if (PhaseNumber == 1)
			{
				Audio.PlaySoundAtTransform(SFX[0].name, transform);
				for (int x = 0; x < NumberBasis.Length; x++)
				{
					Tiles[x].GetComponentInChildren<TextMesh>().text = "-";
					Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0,2,5,7,8,10,13,15) ? new Color32(0,0,0,255) : new Color32(255,0,0,255);
				}
				
				for (int x = 0; x < TormentRange[Tile].Length; x++)
				{
					Tiles[TormentRange[Tile][x]].GetComponentInChildren<TextMesh>().color = new Color32(255,255,255,255);
					Tiles[TormentRange[Tile][x]].GetComponentInChildren<TextMesh>().text = NumberAddition[Tile][x].ToString();
				}
			}
			
			else if (PhaseNumber == 2 && PressNumber < 3 && !new[] {Tile}.Any(c => PressedNumbers.Contains(c)))
			{
				Audio.PlaySoundAtTransform(SFX[0].name, transform);
				for (int z = 0; z < TormentRange[Tile].Length; z++)
				{
					NumberBasis[TormentRange[Tile][z]] = (NumberBasis[TormentRange[Tile][z]] + (NumberAddition[Tile][z])) % 3;
				}
				Tiles[Tile].GetComponentInChildren<TextMesh>().color = new Color32(255,255,255,255);
				
				for (int x = 0; x < NumberBasis.Length; x++)
				{
					Tiles[x].GetComponentInChildren<TextMesh>().text = NumberBasis[x].ToString();
				}
				
				PressedNumbers[PressNumber] = Tile;
				Debug.LogFormat("[Torment #{0}] You pressed {1}", moduleId, CoordinatesCodename[Tile], PressAmount[Tile].ToString());
				PressNumber++;
				
				if (PressNumber == 3)
				{
					Interactable = false;
					for (int x = 0; x < NumberBasis.Length; x++)
					{
						if (NumberBasis[x] != NumberComparer[x])
						{
							return;
						}	
					}
					for (int a = 0; a < 4; a++)
					{
						UNDOING[a].text = "";
					}
					Touchable = false;
					Debug.LogFormat("[Torment #{0}] They have been fully binded. Module solved.", moduleId);
					StartCoroutine(WillAllwaysHappen());
				}
			}
		}
	}
	
	IEnumerator WillAllwaysHappen()
	{
		for (int x = 0; x < NumberBasis.Length; x++)
		{
			Tiles[x].GetComponentInChildren<TextMesh>().color = x.EqualsAny(0,2,5,7,8,10,13,15) ? new Color32(0,0,0,255) : new Color32(255,0,0,255);
			Tiles[x].GetComponentInChildren<TextMesh>().text = "";
		}
		MusicPlayer.clip = SFX[2];
		MusicPlayer.Play();
		while (MusicPlayer.isPlaying)
		{
			 yield return new WaitForSecondsRealtime(0.01f);
		}
		ModuleSolved = true;
		Module.HandlePass();
		MusicPlayer.clip = SFX[1];
		MusicPlayer.Play();
		string[] TheVoidSpeaks = {"WE  WILLCOMEBACK", "THE VOIDWILLLIVE", "YOU WILLSEE SOON", "YOU HAVENOT WON ", "THISWILLNOT END ", "COMEAND JOINUS  ", "NO  ONE TO  HELP", "NO  ONE WILLHELP", "WE  SEE YOUREND ", "YOU ARE NOT SAFE", "YOU WILLBE  BACK", "YOUREYESONLYLIE ", "YOU WILLFEARUS  ", "OUR TIMEWILLCOME", "YOURLIFEWILLEND ", "DO  NOT LOOKBACK", "NO  ONE IS  HERE", "THISIS  THE END "};
		int ChosenDestiny = UnityEngine.Random.Range(0,TheVoidSpeaks.Length);
		while (MusicPlayer.isPlaying)
		{
			for (int x = 0; x < 2; x++)
			{
				for (int y = 0; y < NumberBasis.Length; y++)
				{
					Tiles[y].GetComponentInChildren<TextMesh>().text = x == 0 ? TheVoidSpeaks[ChosenDestiny][y].ToString() : "";
				}
				yield return new WaitForSecondsRealtime(0.1f);
			}
		}
	}

	IEnumerator Ten()
	{
		while (NumberOfSeconds != 0)
		{
            yield return new WaitForSecondsRealtime(1f);
			NumberOfSeconds--;
        }
	}

    //twitch plays
#pragma warning disable 414
    private readonly string TwitchHelpMessage = @"To press the button on top, use the command !{0} look/fall/stop | To press a certain coordinate on the module, use the command !{0} press [A-D][1-4]";
    #pragma warning restore 414
	
    IEnumerator ProcessTwitchCommand(string command)
    {
		yield return null;
		string[] parameters = command.Split(' ');
		if (command.ToUpper() == CodeWord)
		{
			if (!Touchable)
			{
				yield return "sendtochaterror You can not interact with the button currently. Command ignored.";
				yield break;
			}

            if (CodeWord == "STOP" && NumberOfSeconds != 0)
            {
                yield return "sendtochaterror You can not leave yet. Command ignored.";
                yield break;
            }

            UNDO.OnInteract();
		}

		if (Regex.IsMatch(parameters[0], @"^\s*press\s*$", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant))
		{
            if (parameters.Length != 2)
            {
                yield return "sendtochaterror Invalid parameter length. Command ignored.";
                yield break;
            }

            if (!Interactable || !Touchable)
            {
                yield return "sendtochaterror You can not interact with the tiles currently. Command ignored.";
                yield break;
            }

            if (!parameters[1].ToUpper().EqualsAny(CoordinatesCodename))
            {
                yield return "sendtochaterror An invalid coordinate was detected. The command was not continued.";
                yield break;
            }

            if (CodeWord == "STOP" && PressNumber == 2)
            {
                yield return "solve";
            }
            Tiles[Array.IndexOf(CoordinatesCodename, parameters[1].ToUpper())].OnInteract();
        }
	}

}
